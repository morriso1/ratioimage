# AUTOGENERATED! DO NOT EDIT! File to edit: 00_ratio_images.ipynb (unless otherwise specified).

__all__ = ['create_img_dict_from_folder', 'create_ratio_image', 'create_dict_of_ratio_images',
           'measure_region_props_to_tidy_df', 'only_intensity_region_properties',
           'ratiometric_measure_region_props_to_tidy_df', 'split_img_key_col_to_sample_id_and_replicates',
           'sample_id_to_categories']

# Cell
import re

import numpy as np
import pandas as pd
from py_clone_detective.utils import extend_region_properties_list, generate_random_cmap
from skimage import img_as_float, io, measure

# Cell
def create_img_dict_from_folder(
    load_pattern: str, img_regex: str = r"\w\dg\d\d?", label: bool = False, **kwargs
):
    img_collection = io.ImageCollection(load_pattern, **kwargs)

    img_dict = {
        re.search(img_regex, file)[0]: img_collection[i]
        for i, file in enumerate(img_collection.files)
    }

    if label:
        img_dict = {key: measure.label(value) for key, value in img_dict.items()}

    else:
        img_dict = {key: img_as_float(value) for key, value in img_dict.items()}

    return img_dict

# Cell
def create_ratio_image(num_img, denom_img, mask_img):
    # convert label image to mask if passed
    mask_img = mask_img > 0
    ratio = num_img[mask_img] / denom_img[mask_img]
    ratio_image = np.zeros_like(num_img)
    ratio_image[mask_img] = ratio
    return ratio_image

# Cell
def create_dict_of_ratio_images(num_imgs: dict, denom_imgs: dict, lab_imgs: dict):
    ratio_img_dict = {}
    for img_key, lab_img in lab_imgs.items():
        ratio_img_dict[img_key] = create_ratio_image(
            num_imgs[img_key], denom_imgs[img_key], lab_img
        )
    return ratio_img_dict

# Cell
def measure_region_props_to_tidy_df(int_imgs: dict, lab_imgs: dict, **reg_prop_kwargs):
    l = list()
    for img_key, img in int_imgs.items():
        df = pd.DataFrame(
            measure.regionprops_table(
                lab_imgs[img_key], intensity_image=img, **reg_prop_kwargs
            )
        )
        df["img_key"] = img_key

        l.append(df)

    return pd.concat(l)

# Cell
def only_intensity_region_properties(properties):
    return [prop for prop in properties if re.search(r"label|intensity", prop)]

# Cell
def ratiometric_measure_region_props_to_tidy_df(
    num_imgs: dict,
    denom_imgs: dict,
    lab_imgs: dict,
    region_properties: list = None,
    **reg_prop_kwargs
):
    num_rprops = extend_region_properties_list(region_properties)
    denom_rprops = only_intensity_region_properties(num_rprops)

    df = pd.merge(
        measure_region_props_to_tidy_df(num_imgs, lab_imgs, properties=num_rprops),
        measure_region_props_to_tidy_df(denom_imgs, lab_imgs, properties=denom_rprops),
        how="left",
        on=("img_key", "label"),
        suffixes=("_num", "_denom"),
    )

    return df.eval("ratio_mean_int = mean_intensity_num/mean_intensity_denom")

# Cell
def split_img_key_col_to_sample_id_and_replicates(
    df,
    split_regex: str,
    img_key_colname: str = "img_key",
    sample_id_colname: str = "sample_id",
    replicate_id_colname: str = "rep_id",
):
    temp_df = df[img_key_colname].str.split(split_regex, expand=True).iloc[:, :2]
    temp_df.columns = [sample_id_colname, replicate_id_colname]

    return pd.concat([df, temp_df], axis=1)

# Cell
def sample_id_to_categories(
    df,
    sample_id_colname: str = "sample_id",
    old_to_new_sample_ids: dict = None,
    categories: list = None,
):
    if old_to_new_sample_ids is not None:
        df[sample_id_colname].replace(old_to_new_sample_ids, inplace=True)

    df[sample_id_colname] = pd.Categorical(df[sample_id_colname], categories=categories)

    return df